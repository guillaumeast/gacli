###############################
# FICHIER /installer/Brewfile
###############################

brew "curl"
brew "coreutils"
brew "jq"

#!/usr/bin/env sh
###############################
# FICHIER /installer/install.sh
###############################

# Move this file to your shared folder (volume) then run:
# docker run --rm -v "<local_folder_path>:<virtual_folder_path>" -it <image> sh -c ". <virtual_folder_path>/install.sh"

# Options
FORCE_MODE="false"

# Setup variables
ARCH=""
IS_MACOS=false
IS_LINUX=false
SHELL_PATH=""
SHELL_NAME=""

# Urls
URL_REPO="https://github.com/guillaumeast/gacli"
URL_ARCHIVE="${URL_REPO}/archive/refs/heads/dev.tar.gz"

# Paths
DIR_GACLI=".gacli"
FILE_ENTRY_POINT="${DIR_GACLI}/main.zsh"
FILE_ZSHRC=".zshrc"

# Temporary files
DIR_TMP=".gacli_tmp"
DIR_TMP_SRC="${DIR_TMP}/src"
BREWFILE_TMP="${DIR_TMP}/installer/Brewfile"

# WRAPPER
SYM_DIR=".local/bin"
SYMLINK="${SYM_DIR}/gacli"

# Colors
RED="$(printf '\033[31m')"
GREEN="$(printf '\033[32m')"
YELLOW="$(printf '\033[33m')"
CYAN="$(printf '\033[36m')"
ORANGE="$(printf '\033[38;5;208m')"
GREY="$(printf '\033[90m')"
NONE="$(printf '\033[0m')"
BOLD="$(printf '\033[1m')"

# Emojis
EMOJI_SUCCESS="✓"
EMOJI_WARN="⚠️"
EMOJI_ERR="🛑"
EMOJI_INFO="✧"
EMOJI_TBD="⚐"
EMOJI_HIGHLIGHT="→"
EMOJI_DEBUG="🔎"
EMOJI_WAIT="✧ ⏳"

# ────────────────────────────────────────────────────────────────
# PSEUDO-CODE
# ────────────────────────────────────────────────────────────────

# install.sh
    # |→ ✅ init_style                → Enable emojis if system can handle it + welcome message
    # |→ ✅ init_style                → Standardize output formatting
    # |
    # |→ ✅ parse_args                → Inits global variables referring to given args
    # |→ ✅ resolve_paths             → Resolve relative paths to absolute paths
    # |→ ✅ check_env                 → Detect environment: OS, default shell and privilege
    # |
    # |→ ✅ install_brew_deps         → Install Homebrew dependencies with current package manager
    # |→ ✅ install_brew              → Install Homebrew
    # |→ ✅ install_zsh               → Ensure ZSH is the default shell
    # |
    # |→ ✅ download_gacli            → Download GACLI files from Github
    # |→ ✅ install_gacli_deps        → Install GACLI dependencies from BREWFILE_TMP
    # |→ ✅ make_executable           → Ensure GACLI entry point is executable
    # |→ ✅ create_wrapper            → Generate a small shell script to launch GACLI reliably across shells
    # |→ ✅ update_zshrc              → Append GACLI to PATH and source its entry point in ~/.zshrc
    # |
    # |→ ✅ auto_launch               → Launch GACLI
#

# TODO: make zsh default shell
# TODO: add more package managers (apt-get, ziper...)

# ────────────────────────────────────────────────────────────────
# MAIN
# ────────────────────────────────────────────────────────────────

# Entry point that sequences environment checks, download, install and shell reload
main() {

    init_style
    printStyled highlight "Initializing..."
    parse_args "$@" || return 1
    resolve_paths   || return 2

    echo ""
    printStyled highlight "Checking environment..."
    check_env       || return 3

    echo ""
    printStyled highlight "Installing package manager: Homebrew..."
    install_brew    || return 4

    echo ""
    printStyled highlight "Installing GACLI ${GREY}→${CYAN} ${DIR_GACLI}${GREY}...${NONE}"
    download_gacli  || return 5
    install_gacli_deps    || return 6
    make_executable || return 7
    create_wrapper  || return 8
    update_zshrc    || return 9
    cleanup         || return 10

    auto_launch     || return 11
}

# ────────────────────────────────────────────────────────────────
# OUTPUT FORMATTING
# ────────────────────────────────────────────────────────────────

# Prints ASCII banner and activates emoji styling when UTF‑8 is supported
init_style() {
    printf "%s\n" "${ORANGE}  _____          _____ _      _____ ${NONE}"
    printf "%s\n" "${ORANGE} / ____|   /\\   / ____| |    |_   _|${NONE}"
    printf "%s\n" "${ORANGE}| |  __   /  \\ | |    | |      | |  ${NONE}"
    printf "%s\n" "${ORANGE}| | |_ | / /\\ \\| |    | |      | |  ${NONE}"
    printf "%s\n" "${ORANGE}| |__| |/ ____ \\ |____| |____ _| |_ ${NONE}"
    printf "%s\n" "${ORANGE} \\_____/_/    \\_\\_____|______|_____|${NONE}"
    printf "%s\n" ""
}

# Centralised formatter to colour‑code and emoji log messages by severity
printStyled() {
    style=$1
    msg=$2
    color_text=$GREY
    color_emoji=$GREY
    case "${style}" in
        error)
            printf "%s\n" "${EMOJI_ERR} ${RED}${BOLD}${msg}${NONE}" >&2
            return ;;
        warning)
            printf "%s\n" "${EMOJI_WARN}  ${YELLOW}${BOLD}${msg}${NONE}" >&2
            return ;;
        success)
            color_text=$GREY
            color_emoji=$GREEN
            emoji=$EMOJI_SUCCESS
            ;;
        wait)
            color_text=$GREY
            color_emoji=$GREY
            emoji=$EMOJI_WAIT
            ;;
        info)
            color_text=$GREY
            color_emoji=$GREY
            emoji=$EMOJI_INFO
            ;;
        info_tbd)
            color_text=$GREY
            color_emoji=$ORANGE
            emoji=$EMOJI_TBD
            ;;
        highlight)
            color_text=$NONE
            color_emoji=$NONE
            emoji=$EMOJI_HIGHLIGHT
            ;;
        *)
            emoji=""
            ;;
    esac
    printf "%s\n" "${color_emoji}${emoji} ${color_text}${msg}${NONE}"
}

# ────────────────────────────────────────────────────────────────
# CHECK ENV
# ────────────────────────────────────────────────────────────────

# Parses CLI options (currently only --force) and sets corresponding flags
parse_args() {
    for arg in "$@"; do
        case "${arg}" in
            --force)
                FORCE_MODE="true"
                ;;
            *)
                printStyled error "Expected : --force (received : ${arg})"
                return 1
                ;;
        esac
    done
    printStyled success "Arguments: ${GREEN}parsed${NONE}"
}

# Expands user‑relative paths, ensures .zshrc exists, and defines wrapper installers
resolve_paths() {

    # Ensure $HOME is set
    [ -n "${HOME}" ] || { printStyled error "\$HOME not set"; return 1; }

    # Main paths
    DIR_GACLI="${HOME}/${DIR_GACLI}"
    FILE_ENTRY_POINT="${HOME}/${FILE_ENTRY_POINT}"
    FILE_ZSHRC="${HOME}/${FILE_ZSHRC}"

    # Symlink paths
    SYM_DIR="${HOME}/${SYM_DIR}"
    SYMLINK="${HOME}/${SYMLINK}"

    # Temporary paths
    DIR_TMP="${HOME}/${DIR_TMP}"
    DIR_TMP_SRC="${HOME}/${DIR_TMP_SRC}"
    BREWFILE_TMP="${HOME}/${BREWFILE_TMP}"

    # Reset temporary files
    [ -d "${DIR_TMP}" ] && rm -rf "${DIR_TMP}"
    mkdir -p "${DIR_TMP}"

    # Log
    printStyled success "Paths: ${GREEN}resolved${NONE}"
}

# Detects OS, default shell and privilege
check_env() {

    # Detect arch
    ARCH="$(uname -m)"
    printStyled success "Arch: ${GREEN}${ARCH}${NONE}"

    # Detect OS via uname
    ud=$(uname -s)
    case "${ud}" in
        Darwin) IS_MACOS=true ;;
        Linux)  IS_LINUX=true ;;
        *)      printStyled error "Unsupported OS: ${ud}"; return 1 ;;
    esac
    printStyled success "OS: ${GREEN}${ud}${NONE}"

    # Detect distribution
    if [ "${IS_LINUX}" = true ]; then
    
        # Read /etc/os-release to get the distro pretty-name (fallback to ID)
        if [ -r /etc/os-release ]; then
            . /etc/os-release
            distro="${NAME:-${ID}}"
        else
            distro="unknown"
        fi
        
        # Alpine is unsupported (musl instead of glibc)
        if echo "${distro}" | grep -qi alpine; then
            printStyled info "Distribution: ${RED}${distro}${NONE}"
            printStyled error "Distribution not supported → please use a ${ORANGE}glibc-based${RED} distribution"
            return 1
        fi

        # Success
        printStyled success "Distribution: ${GREEN}${distro}${NONE}"
    fi

    # Detect default shell
    SHELL_PATH=${SHELL:-$(command -v sh)}
    SHELL_NAME=$(basename "$SHELL_PATH")
    style=""
    color=""
    if [ ${SHELL_NAME} = "zsh" ]; then
        style="success"
        color="${GREEN}"
    elif [ -n "${SHELL_NAME}" ]; then
        style="info_tbd"
        color="${ORANGE}"
    else
        style="info"
        color="${RED}"
        SHELL_NAME="unknwon"
    fi
    printStyled "${style}" "Default shell: ${color}${SHELL_NAME}${GREY} → ${CYAN}${SHELL_PATH}${NONE}"

    # — Privilege escalation setup —
    if [ "$(id -u)" -ne 0 ]; then
        if command -v sudo >/dev/null 2>&1; then
            SUDO="sudo "
            printStyled success "Privilege: ${GREEN}sudo enabled${NONE}"
        else
            SUDO=""
            printStyled info_tbd "Privilege: ${ORANGE}No sudo detected${GREY} → non-root installs may fail${NONE}"
        fi
    else
        SUDO=""
        printStyled success "Privilege: ${GREEN}root${NONE}"
    fi
}

# ────────────────────────────────────────────────────────────────
# SETUP ENV
# ────────────────────────────────────────────────────────────────

# Installs Homebrew when absent, selecting curl or wget as downloader
install_brew() {
    
    # Check if Installed
    if command -v brew >/dev/null 2>&1; then
        printStyled success "Detected: ${GREEN}Homebrew${NONE}"
        return 0
    fi

    # Install Homebrew dependencies
    install_brew_deps || return 1

    # Setup Linux env
    if [ "$IS_LINUX" = true ]; then
        mkdir -p /home/linuxbrew/.linuxbrew || {
            printStyled error "Unable to create Homebrew folder: /home/linuxbrew/.linuxbrew"
            return 1
        }
        chown -R "$(id -un):$(id -gn)" /home/linuxbrew/.linuxbrew || {
            printStyled error "Unable to make Homebrew folder writable: /home/linuxbrew/.linuxbrew"
            return 1
        }
    fi

    # Install
    printStyled wait "Downloading Homebrew..."
    bash_path="$(command -v bash || printf %s '/bin/bash')"
    brew_installer_url="https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh"
    yes '' | "${bash_path}" -c "$(curl -fsSL "${brew_installer_url}")" || { # TODO: >/dev/null 2>&1
        printStyled error "Unable to install ${ORANGE}Homebrew${NONE}"
        return 1
    }
    printStyled success "Downloaded: ${GREEN}Homebrew${NONE}"
    
    # Configure Linux env
    if [ "$IS_LINUX" = true ]; then
        files="/root/.profile /root/.kshrc /root/.bashrc /root/.zshrc /root/.dashrc /root/.tcshrc /root/.cshrc"
        brew_path=""
        brew_shellenv=""

        # Resolve brew path
        location_1="/home/linuxbrew/.linuxbrew/bin/brew"
        location_2="/home/linuxbrew/.linuxbrew/Homebrew/bin/brew"
        if command -v brew; then
            brew_path="$(command -v brew)"
        elif [ -x "${location_1}" ]; then
            brew_path=$location_1
        elif [ -x "${location_2}" ]; then
            brew_path=$location_2
        else
            printStyled error "Unable to locate ${ORANGE}Homebrew${RED} binary"
            return 1
        fi

        # Resolve brew shellenv output
        brew_shellenv="$("${brew_path}" shellenv)" || {
            printStyled error "Unable to fetch ${ORANGE}brew shellenv${NONE}"
            return 1
        }

        # Add Homebrew to all source files
        touch "/root/.zshrc"
        for file in $files; do
            [ ! -f "${file}" ] && continue
            echo "" >> "${file}"
            echo "eval \"${brew_shellenv}\"" >> "${file}"
        done

        # Add Homebrew to current session
        eval "${brew_shellenv}"

        # Install gcc if missing
        if ! command -v gcc >/dev/null 2>&1; then
            brew install gcc >/dev/null 2>&1 || {
                printStyled error "Unable to install ${ORANGE}gcc${NONE}"
                return 1
            }
        fi
        printStyled success "Configured: ${GREEN}Linuxbrew${NONE}"
    fi

    # Check install
    if ! command -v brew >/dev/null 2>&1; then
        printStyled error "Unable to install ${ORANGE}Homebrew${NONE}"
        return 1
    fi
    
    # Success
    printStyled success "Installed: ${GREEN}Homebrew${NONE}"
}

# Installs Homebrew dependencies
install_brew_deps() {

    # TODO: macOS default package manager ?

    # Variables
    default_deps="file git curl bash zsh coreutils jq"

    # ✅ Supported
    if command -v brew >/dev/null 2>&1; then
        package_manager="brew"
        step_1="brew install coreutils"
        step_2="brew install jq"
    elif command -v apt >/dev/null 2>&1; then
        package_manager="apt"
        step_1="${SUDO}apt-get update -y"
        step_2="${SUDO}apt-get install -y build-essential ${default_deps} procps"
        cmd="${step_1} && ${step_2}"
    elif command -v urpmi >/dev/null 2>&1; then
        package_manager="urpmi"
        step_1="${SUDO}urpmi.update -a"
        step_2="${SUDO}urpmi --auto ${default_deps} procps-ng gcc make binutils"
        cmd="${step_1} && ${step_2}"
    elif command -v dnf >/dev/null 2>&1; then
        if dnf --version 2>/dev/null | grep -q "5\."; then
            package_manager="dnf v5"
            step_1="${SUDO}dnf install -y @development-tools"
        else
            package_manager="dnf v4"
            step_1="${SUDO}dnf group install -y \"Development Tools\""
        fi
        step_2="${SUDO}dnf install -y ${default_deps} procps-ng gawk"
        cmd="${step_1} && ${step_2}"
    elif command -v pacman >/dev/null 2>&1; then
        package_manager="pacman"
        cmd="${SUDO}pacman -Sy --noconfirm base-devel ${default_deps} procps-ng"
    elif command -v zypper >/dev/null 2>&1; then
        package_manager="zypper"
        step_1="${SUDO}zypper refresh"
        step_2="${SUDO}zypper install -y -t pattern devel_basis && ${SUDO}zypper install -y ${default_deps} procps gzip ruby"
        cmd="${step_1} && ${step_2}"
    elif command -v emerge >/dev/null 2>&1; then
        package_manager="emerge"
        step_1="${SUDO}emerge --sync"
        step_2="${SUDO}emerge -n --quiet sys-devel/gcc sys-devel/binutils sys-apps/file dev-vcs/git net-misc/curl app-shells/bash app-shells/zsh sys-apps/coreutils app-misc/jq sys-process/procps"
        cmd="${step_1} && ${step_2}"
    elif command -v slackpkg >/dev/null 2>&1; then
        package_manager="slackpkg"
        step_1="${SUDO}slackpkg update"
        step_2="yes | ${SUDO}slackpkg install ${default_deps} procps-ng gcc make binutils nghttp2 brotli cyrus-sasl ca-certificates perl"
        step_3="${SUDO}update-ca-certificates --fresh"
        cmd="${step_1} && ${step_2} && ${step_3}"
    elif command -v pkg >/dev/null 2>&1; then
        package_manager="pkg"
        step_1="${SUDO}pkg update -f"
        step_2="${SUDO}pkg install -y ${default_deps} procps gcc gmake binutils"
        cmd="${step_1} && ${step_2}"

    # 🛑 Unsupported
    elif command -v apk >/dev/null 2>&1; then
        printStyled error "Unsupported package manager: ${ORANGE}apk${RED} (glibc-based distribution required)"
        return 1
    elif command -v yum >/dev/null 2>&1; then
        printStyled error "Unsupported package manager: ${ORANGE}yum${RED} (git ≥ 2.7.0 not available)"
        return 1
    elif command -v nix-env >/dev/null 2>&1; then
        printStyled error "Unsupported package manager: ${ORANGE}nix-env${RED} (FHS required)"
        return 1
    elif command -v xbps-install >/dev/null 2>&1; then
        printStyled error "Unsupported package manager: ${ORANGE}xbps${RED} (server-side SSL/TLS issues)"
        return 1
    else
        printStyled error "No supported package manager found"
        return 1
    fi


    printStyled info_tbd "Current package manager: ${ORANGE}${package_manager}${NONE}"
    printStyled wait "Installing Homebrew dependencies → ${ORANGE}${EMOJI_WARN}  This may take a while, please wait...${NONE}"
    eval "${cmd}" || { # TODO: >/dev/null 2>&1
        printStyled error "Unable to install Homebrew dependencies"
        return 1
    }

    # Success
    printStyled success "Installed: ${GREEN}Homebrew dependencies${NONE}"
}

# ────────────────────────────────────────────────────────────────
# INSTALL GACLI
# ────────────────────────────────────────────────────────────────

# Retrieves GACLI source (curl, wget or git) into the installer directory, honouring --force
download_gacli() {

    # Log
    printStyled wait "Downloading GACLI..."

    # Delete previous install if --force, else abort
    if [ -d "${DIR_GACLI}" ]; then
        if [ "${FORCE_MODE}" = "true" ]; then
            rm -rf "${DIR_GACLI}"
        else
            printStyled error "Gacli already installed. Use --force to overwrite"
            return 1
        fi
    fi

    # Download all repo in tmp folder
    curl -fsSL "${URL_ARCHIVE}" | tar -xzf - -C "${DIR_TMP}" --strip-components=1 >/dev/null 2>&1 || {
        printStyled error "Download failed"
        return 1
    }

    # Copy source files
    mv "${DIR_TMP_SRC}" "${DIR_GACLI}" || {
        printStyled error "Unable to move files into: ${DIR_GACLI}"
        return 1
    }

    printStyled success "Downloaded: ${GREEN}GACLI${NONE}"
}

# Runs brew bundle on the downloaded BREWFILE_TMP to install required formulae and casks
install_gacli_deps() {

    # Log
    printStyled wait "Installing GACLI dependencies..."

    # Check Brewfile integrity
    [ -f "${BREWFILE_TMP}" ] || {
        printStyled error "Unable to find dependencies descriptor at: ${CYAN}${BREWFILE_TMP}${NONE}"
        return 1
    }

    # Check Homebrew install
    command -v brew >/dev/null 2>&1 || {
        printStyled error "Unable to find ${ORANGE}Homebrew${NONE}"
        return 1     
    }

    # Install dependencies
    brew bundle --file="${BREWFILE_TMP}" >/dev/null 2>&1 || {
        printStyled error "Failed to install dependencies with ${ORANGE}Homebrew${NONE}"
        return 1
    }

    # Log
    printStyled success "Installed: ${GREEN}GACLI dependencies${NONE}"
}

# Adds execute permission to the downloaded GACLI entry‑point script
make_executable() {
    chmod +x "${FILE_ENTRY_POINT}" || {
        printStyled warning "Failed to make ${CYAN}${FILE_ENTRY_POINT}${YELLOW} executable"
        return 1
    }
    printStyled success "Made executable: ${GREEN}Entry point${NONE}"
}

# Generates a wrapper in $HOME/.local/bin that relays args to the entry point via zsh
create_wrapper() {

    # Create symlink dir if missing
    mkdir -p "${SYM_DIR}" || {
        printStyled warning "Failed to create ${CYAN}${SYM_DIR}${NONE}"; return 1
    }

    # Delete symlink if already exists
    if [ -f "${SYMLINK}" ] || [ -d "${SYMLINK}" ] || [ -L "${SYMLINK}" ]; then
        rm -f "${SYMLINK}"
    fi

    # Create symlink
    {
        printf '%s\n' '#!/usr/bin/env sh'
        printf '%s\n' "exec \"$(command -v zsh)\" \"${FILE_ENTRY_POINT}\" \"\$@\""
    } > "${SYMLINK}" && chmod +x "${SYMLINK}" || {
        printStyled warning "Failed to create ${ORANGE}wrapper${NONE}"; return 1
    }

    # Success
    printStyled success "Created: ${GREEN}wrapper${GREY} → ${CYAN}${SYMLINK}${GREY} → ${CYAN}${FILE_ENTRY_POINT}${NONE}"
}

# Appends PATH export and source command to the user’s .zshrc when missing
update_zshrc() {

    touch "${FILE_ZSHRC}" || {
        printStyled error "Unable to create .zshrc file: ${CYAN}${FILE_ZSHRC}${NONE}"
        return 1
    }

    if grep -q '# GACLI' "${FILE_ZSHRC}"; then
        printStyled success "Zsh : ${GREEN}configured${NONE}"
        return 0
    fi
    {
        printf '\n\n# GACLI\n'
        printf 'export PATH="%s:$PATH"\n' "${SYM_DIR}"
        printf 'source "%s"\n' "${FILE_ENTRY_POINT}"
    } >> "${FILE_ZSHRC}" || {
        printStyled warning "Failed update ${FILE_ZSHRC}"; return 1
    }
    printStyled success "Configured: ${GREEN}zsh${NONE}"
}

# Deletes installer and temporary files
cleanup() {

    # Resolve installer symlinks
    installer="$0"
    while [ -L "${installer}" ]; do
        dir="$(dirname "${installer}")"
        installer="$(readlink "${installer}")"
        case "${installer}" in
        /*) ;;
        *) installer="${dir}/${installer}" ;;
        esac
    done
    dir="$(dirname "${installer}")"
    base="$(basename "${installer}")"

    # Move to installer directory and get absolute path
    # TODO: do not change activ dir !!
    cd "${dir}" >/dev/null 2>&1 || return 1
    abs_dir="$(pwd -P)" || return 1
    installer="${abs_dir}/${base}"

    # Delete installer
    [ -f "${installer}" ] && rm -f "${installer}"

    # Delete temporary files
    [ -d "${DIR_TMP}" ] && rm -rf "${DIR_TMP}"

    # Log
    printStyled success "Cleanup: ${GREEN}completed${NONE}"
}

# ────────────────────────────────────────────────────────────────
# RUN
# ────────────────────────────────────────────────────────────────

# Displays success message and either execs a new zsh or prompts the user to reopen a shell
# TODO: add --no-launch option to avoid auto_launch for test purposes
auto_launch() {
    echo ""
    printStyled success "${GREEN}GACLI successfully installed${NONE} 🚀"
    echo ""
    if command -v zsh >/dev/null 2>&1; then
        printStyled info "Reloading shell..."
        exec zsh
    else
        printStyled error "Missing dependencie: ${ORANGE}zsh${NONE}"
        echo ""
        return 1
    fi
}


main "$@"

#!/usr/bin/env zsh
###############################
# FICHIER /src/helpers/time.zsh
###############################

TIME_CMD=""

# ────────────────────────────────────────────────────────────────
# INIT
# ────────────────────────────────────────────────────────────────

# Set TIME_CMD depending on platform (gdate or date)
time_init() {

    if command -v gdate > /dev/null 2>&1; then
        TIME_CMD="gdate"
    elif command -v date > /dev/null 2>&1; then
        TIME_CMD="date"
    else
        printStyled error "Unable to find ${ORANGE}gdate${NONE} or ${ORANGE}date${NONE}"
        return 1
    fi
}

# ────────────────────────────────────────────────────────────────
# PUBLIC
# ────────────────────────────────────────────────────────────────

# Returns current timestamp
time_get_current() {

    # Variables
    local current_ts

    # Resolve TIME_CMD depending on platform
    time_init || return 1

    # Fetch current date
    if ! current_ts="$("${TIME_CMD}" +%s)"; then
        printStyled error "Failed to get current timestamp"
        return 1
    fi

    # Return value
    echo "${current_ts}"
}

# Add a number of days to a timestamp and return result as timestamp
time_add_days() {

    # Variables
    local start_ts="$1"
    local add="$2"

    # Resolve TIME_CMD depending on platform
    time_init || return 1

    # Arguments checks
    if [[ -z "${start_ts}" || -z "${add}" ]]; then
        printStyled error "Expected : <start_ts> <add> (received : ${1} ${2})"
        return 1
    fi
    if ! [[ "${start_ts}" =~ ^[0-9]+$ && "${add}" =~ ^[0-9]+$ ]]; then
        printStyled error "Both arguments must be positive integers"
        return 1
    fi

    # Compute
    echo $((86400 * $add + $start_ts))
}

# Convert UNIX timestamp to YYYY-MM-DD
time_to_human() {

    # Variables
    local ts="$1"

    # Resolve TIME_CMD depending on platform
    time_init || return 1

    # Arguments checks
    if [[ -z "$ts" || ! "$ts" =~ ^[0-9]+$ ]]; then
        printStyled error "Expected a timestamp (received: ${1})"
        return 1
    fi

    # Convert
    if ! "${TIME_CMD}" -u -d "@$ts" "+%Y-%m-%d"; then
        printStyled error "Conversion failed"
        return 1
    fi
}

# Convert YYYY-MM-DD to UNIX timestamp
time_from_human() {

    # Variables
    local date_str="${1}"

    # Resolve TIME_CMD depending on platform
    time_init || return 1

    # Arguments checks
    if [[ -z "${date_str}" || ! "${date_str}" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
        printStyled error "Expected format: YYYY-MM-DD (received: ${1})"
        return 1
    fi

    # Convert
    if ! "${TIME_CMD}" -u -d "${date_str}" +%s; then
        printStyled error "Conversion failed"
        return 1
    fi
}

#!/usr/bin/env zsh
###############################
# FICHIER /src/helpers/parser.zsh
###############################

# TODO: add boolean and numeric format support (JSON)

# ────────────────────────────────────────────────────────────────
# PUBLIC
# ────────────────────────────────────────────────────────────────

# PUBLIC - Read a scalar/list value from any file
# file_read <file> <key>
file_read() {
  local file=$1
  local key=$2
  local extension=""

  # Check file integrity
  if [[ ! -f $file ]]; then
    printStyled error "Unable to find file: ${file}"
    return 1
  fi

  # Check key intergity
  if [[ -z $key ]]; then
    printStyled error "Incorrect key: '${key}'"
    return 1
  fi

  # Get extension
  if ! extension=$(_get_extension $file); then
    printStyled error "Unable to detect file format: ${file}"
    return 1
  fi

  # Dispatch
  case "$extension" in
    json)
      echo "$(_json_read "${file}" "${key}")" || return 1
      ;;
    brewfile)
      echo "$(_brew_read "${file}" "${key}")" || return 1
      ;;
    *)
      printStyled error "Format not supported: ${extension}"
      return 1
      ;;
  esac
}

# PUBLIC - Write a scalar value into any file
# file_write <file> <key> <value>
file_write() {
  local file=$1
  local key=$2
  local value=$3
  local extension=""

  # Check file integrity
  if [[ ! -f $file ]]; then
    printStyled error "Unable to find file: ${file}"
    return 1
  fi

  # Check key intergity
  if [[ -z $key ]]; then
    printStyled error "Incorrect key: '${key}'"
    return 1
  fi

  # Get extension
  if ! extension=$(_get_extension $file); then
    printStyled error "Unable to detect file format: ${file}"
    return 1
  fi

  # Dispatch
  case "$extension" in
    json)
      _json_write "${file}" "${key}" "${value}" || return 1
      ;;
    brewfile)
      _brew_add "${file}" "${key}" "${value}" || return 1
      ;;
    *)
      printStyled error "Format not supported: ${extension}"
      return 1
      ;;
  esac
}

# PUBLIC - Reset a list value into any file
file_reset() {
  local file=$1
  local key=$2
  local extension=""

  # Check file integrity
  if [[ ! -f $file ]]; then
    printStyled error "Unable to find file: ${file}"
    return 1
  fi

  # Check key intergity
  if [[ -z $key ]]; then
    printStyled error "Incorrect key: '${key}'"
    return 1
  fi

  # Get extension
  if ! extension=$(_get_extension $file); then
    printStyled error "Unable to detect file format: ${file}"
    return 1
  fi

  # Dispatch
  case "$extension" in
    json)
      _json_reset "${file}" "${key}" || return 1
      ;;
    brewfile)
      _brew_reset "${file}" "${key}" || return 1
      ;;
    *)
      printStyled error "Format not supported: ${extension}"
      return 1
      ;;
  esac
}

# PUBLIC - Add a list of values to a list into any file
file_add() {
  local file=$1
  local key=$2
  shift 2               # Remove the two first args
  local values=("$@")   # Remaining args are the list of values to add
  local extension=""

  # Check file integrity
  if [[ ! -f $file ]]; then
    printStyled error "Unable to find file: ${file}"
    return 1
  fi

  # Check key intergity
  if [[ -z $key ]]; then
    printStyled error "Incorrect key: '${key}'"
    return 1
  fi

  # Get extension
  if ! extension=$(_get_extension $file); then
    printStyled error "Unable to detect file format: ${file}"
    return 1
  fi

  # Dispatch
  case "$extension" in
    json)
        for value in "${values[@]}"; do
            _json_add "${file}" "${key}" "${value}" || return 1
        done
        ;;
    brewfile)
        for value in "${values[@]}"; do
            _brew_add "${file}" "${key}" "${value}" || return 1
        done
        ;;
    *)
      printStyled error "Format not supported: ${extension}"
      return 1
      ;;
  esac
}

# PUBLIC - Remove a list of values from a list into any file
file_rm() {
  local file=$1
  local key=$2
  shift 2               # Remove the two first args
  local values=("$@")   # Remaining args are the list of values to add
  local extension=""

  # Check file integrity
  if [[ ! -f $file ]]; then
    printStyled error "Unable to find file: ${file}"
    return 1
  fi

  # Check key intergity
  if [[ -z $key ]]; then
    printStyled error "Incorrect key: '${key}'"
    return 1
  fi

  # Get extension
  if ! extension=$(_get_extension $file); then
    printStyled error "Unable to detect file format: ${file}"
    return 1
  fi

  # Dispatch
  case "$extension" in
    json)
        for value in "${values[@]}"; do
            _json_rm "${file}" "${key}" "${value}" || return 1
        done
        ;;
    brewfile)
        for value in "${values[@]}"; do
            _brew_rm "${file}" "${key}" "${value}" || return 1
        done
        ;;
    *)
      printStyled error "Format not supported: ${extension}"
      return 1
      ;;
  esac
}

# ────────────────────────────────────────────────────────────────
# PRIVATE
# ────────────────────────────────────────────────────────────────

# PRIVATE - Return file extension in lowercase (special case for Brewfile)
# __get_extension <file>
_get_extension() {
    local file="${1}"
    local file_name="${file##*/}"
    local extension="${file##*.}"

    if [[ $file_name = "Brewfile" ]]; then
        extension="Brewfile"
    fi

    echo "${extension:l}"
}

# ────────────────────────────────────────────────────────────────
# JSON
# ────────────────────────────────────────────────────────────────

# PRIVATE - Read scalar/list value from JSON file
# _json_read <file> <key>
_json_read() {
  local file=$1
  local key=$2
  local output=()

  # Check if the key exists
  if ! jq -e "has(\"$key\")" "$file" >/dev/null; then
    print "${RED}Error: key '${key}' does not exist in ${file}${NONE}" >&2
    return 1
  fi

  # Get the value type
  local type=$(jq -r ".${key} | type" "$file") || {
    print "${RED}Error: unable to fetch key '${key}' type in ${file}${NONE}" >&2
    return 1
  }

  case "$type" in
    "null")
      # Key exists but value is null → return empty string
      echo $output
      ;;
    "string")
      output=("${(Q)$(jq -r ".${key}" "$file")}")
      echo $output
      ;;
    "array")
      output=("${(@f)$(jq -r ".${key}[]" "$file")}")
      printf '%s\n' "${output[@]}"
      ;;
    *)
      print "${RED}Error: unsupported type '${type}' for key '${key}'${NONE}" >&2
      echo $output
      return 1
      ;;
  esac
}

# PRIVATE - Write scalar value into JSON file
# _json_write <file> <key> <value>
_json_write() {
  local file=$1
  local key=$2
  local value=$3

  jq --arg key "$key" --arg value "$value" '.[$key] = $value' "$file" > "${file}.tmp" || return 1
  command mv -f "${file}.tmp" "${file}" || return 1
}

# PRIVATE - Reset list value into JSON file
# _json_reset <file> <key>
_json_reset() {
  local file=$1
  local key=$2

  jq --arg key "$key" '.[$key] = null' "$file" > "${file}.tmp" || return 1
  command mv -f "${file}.tmp" "$file" || return 1
}

# PRIVATE - Add value to a list into JSON file
# _json_add <file> <key> <value>
_json_add() {
  local file=$1
  local key=$2
  local value=$3

  jq --arg key "$key" --arg value "$value" '.[$key] += [$value]' "$file" > "${file}.tmp" || return 1
  command mv -f "${file}.tmp" "$file" || return 1
}

# PRIVATE - Remove value from a list into JSON file
# _json_rm <file> <key> <value>
_json_rm() {
  local file=$1
  local key=$2
  local value=$3

  jq --arg key "$key" --arg value "$value" '.[$key] |= map(select(. != $value))' "$file" > "${file}.tmp" || return 1
  command mv -f "${file}.tmp" "$file" || return 1
}

# ────────────────────────────────────────────────────────────────
# Brewfile
# ────────────────────────────────────────────────────────────────


# PRIVATE - Read values from a Brewfile (formulae or casks)
# _brew_read <file> <key>
_brew_read() {
  local file="${1}"
  local key="${2}"
  local output=()

  case "${key}" in
    formulae)
      output=("${(@f)$(grep '^brew "' "$file" | cut -d'"' -f2 2>/dev/null)}")
      ;;
    casks)
      output=("${(@f)$(grep '^cask "' "$file" | cut -d'"' -f2 2>/dev/null)}")
      ;;
    *)
      printStyled error "Unknown key for brewfile: '${key}'"
      return 1
      ;;
  esac

  printf '%s\n' "${output[@]}"
}

# PRIVATE - Reset list value into a Brewfile
# _brew_reset <file> <key>
_brew_reset() {
  local file="${1}"
  local key="${2}"
  local tmp_file="$(mktemp)"

  case "${key}" in
      formulae)
          grep -v '^brew "' "${file}" > "${tmp_file}" || {
              printStyled error "Failed to clean formulae from ${file}"
              rm -f "$tmp_file"
              return 1
          }
          ;;
      casks)
          grep -v '^cask "' "${file}" > "${tmp_file}" || {
              printStyled error "Failed to clean casks from ${file}"
              rm -f "$tmp_file"
              return 1
          }
          ;;
      *)
          printStyled error "Unknown key for Brewfile: ${key}"
          rm -f "$tmp_file"
          return 1
          ;;
  esac

  command mv -f "${tmp_file}" "${file}" || {
    printStyled error "Failed to overwrite ${file}"
    rm -f "$tmp_file"
    return 1
  }
}

# PRIVATE - Add value to a list into a Brewfile (append line if not already present)
# _brew_add <file> <key> <value>
_brew_add() {
  local file="${1}"
  local key="${2}"
  local value="${3}"
  local line=""

  case "${key}" in
    formulae)
      line="brew \"${value}\""
      ;;
    casks)
      line="cask \"${value}\""
      ;;
    *)
      printStyled error "Unknown key for brewfile: '${key}'"
      return 1
      ;;
  esac

  if ! grep -qF "${line}" "${file}"; then
    # Ensure newline at EOF before appending
    [[ $(tail -c1 "${file}") != "" ]] && echo >> "${file}"

    # Append value
    echo "${line}" >> "${file}" || {
      printStyled error "Failed to append line to ${file}"
      return 1
    }
  fi
}

# PRIVATE - Remove value from a list into a Brewfile
# _brew_rm <file> <key> <value>
_brew_rm() {
  local file=$1
  local key=$2
  local value=$3

  local pattern=""
  case "${key}" in
    formulae)
      pattern="^brew \"${value}\""
      ;;
    casks)
      pattern="^cask \"${value}\""
      ;;
    *)
      printStyled error "Unknown key for brewfile: '${key}'"
      return 1
      ;;
  esac

  grep -v "${pattern}" "$file" > "${file}.tmp" || {
    printStyled error "Failed to remove line from ${file}"
    return 1
  }

  command mv -f "${file}.tmp" "${file}" || {
    printStyled error "Failed to overwrite ${file} after removal"
    return 1
  }
}

#!/usr/bin/env zsh
###############################
# FICHIER /src/helpers/brew.zsh
###############################

# ────────────────────────────────────────────────────────────────
# PUBLIC
# ────────────────────────────────────────────────────────────────

# PUBLIC - Run Homebrew update, bundle, upgrade and cleanup
brew_bundle() {
    local brewfile="${1}"

    # Install Homebrew if missing
    _brew_install || {
        printStyled error "Missing required dependencie: Homebrew"
        return 1
    }

    # Loading mesage
    print ""
    printStyled "info" "Updating... (this may take a few minutes) ⏳"

    # Update Homebrew
    if ! brew update  > /dev/null 2>&1; then
        printStyled warning "Failed to update Homebrew"
    fi

    # Install/uninstall formulae & casks referring to the Brewfile
    if ! brew bundle --file="${brewfile}" 1>/dev/null; then
        printStyled error "Failed to run bundle Homebrew"
        return 1
    fi

    # Upgrade
    if ! brew upgrade 1>/dev/null; then
        printStyled error "Failed to upgrade Homebrew packages"
        return 1
    fi

    # Cleanup
    if ! brew cleanup 1>/dev/null; then
        printStyled warning "Failed to cleanup Homebrew packages"
    fi
}

# PUBLIC - Check if given formula is active
brew_is_f_active() {

    # Install Homebrew if missing
    _brew_install || {
        printStyled error "Missing required dependencie: Homebrew"
        return 1
    }

    local formula="${1}"
    [[ "$formula" = "coreutils" ]] && formula="gdate"

    command -v $formula >/dev/null 2>&1 || return 1
}

# PUBLIC - Check if given cask is active
brew_is_c_active() {
    local cask="${1}"

    # Install Homebrew if missing
    _brew_install || {
        printStyled error "Missing required dependencie: Homebrew"
        return 1
    }

    # "my-cask-name" → "My Cask Name.app"
    local app_name="$(echo "$cask" | sed -E 's/-/ /g' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) substr($i,2)} 1').app"

    # Check .app folders first for speed, fallback to brew if missing
    [[ -d "/Applications/$app_name" || -d "$HOME/Applications/$app_name" ]] && return 0
    brew list --cask "$cask" >/dev/null 2>&1 || return 1
}

# ────────────────────────────────────────────────────────────────
# PRIVATE
# ────────────────────────────────────────────────────────────────

# PRIVATE - Install Homebrew
_brew_install() {

    # Check if Homebrew is already installed
    if command -v brew > /dev/null 2>&1; then
        return 0
    fi
    printStyled info "Installing ${ORANGE}Homebrew${GREY}... ⏳"

    # Resolve install command
    local install_cmd="/bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
    if $IS_MACOS || $IS_LINUX; then
        if $IS_LINUX; then
            install_cmd="NONINTERACTIVE=1 ${install_cmd}"
        fi
    else
        printStyled error "Unsupported OS: ${OSTYPE}"
        return 1
    fi

    # Execute install command
    if ! eval "$install_cmd"; then
        printStyled error "Homebrew installation failed"
        return 1
    fi

    # Add Homebrew to PATH
    local brew_exec_path
    if ! brew_exec_path="$(command -v brew)"; then
        printStyled error "Failed to detect brew after installation"
        return 1
    fi

    # Check if install is successful
    if ! eval "$("$brew_exec_path" shellenv)"; then
        printStyled error "Failed to set Homebrew environment"
        return 1
    fi

    # Refresh command hash table
    if ! hash -r; then
        printStyled warning "Failed to refresh shell hash table"
    fi
}

#!/usr/bin/env zsh
###############################
# FICHIER /src/logic/update.zsh
###############################

TODAY=""

# Config
INITIALIZED=""
LAST_UPDATE=""
AUTO_UPDATE=""
FREQ_DAYS=""
NEXT_UPDATE=""

# ────────────────────────────────────────────────────────────────
# AUTO-UPDATE
# ────────────────────────────────────────────────────────────────

# PUBLIC - Initialize config process and trigger auto-update if needed
update_init() {
    local tmp_brewfile="${DIR_TMP}/Brewfile"

    # Get config values
    _update_get_config || {
        printStyled error "Unable to load config"
        return 1
    }

    # Merge dependencies
    update_merge_into "${tmp_brewfile}" || {
        printStyled error "Unable to merge dependencies"
        rm -f "${tmp_brewfile}"
        return 1
    }

    # Run update if needed
    if [[ $(_update_is_reached) || $(_update_is_required "${tmp_brewfile}") ]]; then
        _update_run_from "${tmp_brewfile}" || printStyled warning "Unable to run update"
    fi

    # Delete temporary Brewfile
    rm -f "${tmp_brewfile}"
}

# PRIVATE - Check if the scheduled auto-update date is reached
_update_is_reached() {

    # Check if auto update is enabled
    [[ "${AUTO_UPDATE}" = "false" ]] && return 1

    # Check if next_update is defined
    if [[ -z "$NEXT_UPDATE" || ! "$NEXT_UPDATE" =~ ^[0-9]+$ ]]; then
        printStyled warning "Unable to parse next update date: '${NEXT_UPDATE}' \n    └→ Auto-update disabled"
        AUTO_UPDATE="false" && NEXT_UPDATE=""
        _update_set_config
        return 1
    fi

    # Check if next_update is reached
    if (( TODAY < NEXT_UPDATE )); then
        return 1
    fi
}

# PRIVATE - Check if any required dependency is missing in the system
_update_is_required() {
    local brewfile="${1}"
    local dependencies=()
    local dependencie=""

    # Check if formulae are missing
    dependencies=("${(@f)$(file_read "${brewfile}" formulae)}")
    for dependencie in "${dependencies[@]}"; do
        brew_is_f_active "${dependencie}" || return 0
    done

    # Check if casks are missing
    dependencies=("${(@f)$(file_read "${brewfile}" casks)}")
    for dependencie in "${dependencies[@]}"; do
        brew_is_c_active "${dependencie}" || return 0
    done

    return 1
}

# ────────────────────────────────────────────────────────────────
# MANUAL UPDATE
# ────────────────────────────────────────────────────────────────

# PRIVATE - Run manual update by merging and applying all dependencies
_update_manual() {
    local tmp_brewfile="${DIR_TMP}/Brewfile"

    # Merge all dependencies
    update_merge_into "${tmp_brewfile}" || {
        printStyled error "Unable to merge dependencies"
        rm -f "${tmp_brewfile}"
        return 1
    }

    _update_run_from "${tmp_brewfile}" || {
        printStyled error "Update failed"
        rm -f "${tmp_brewfile}"
        return 1
    }
}

# PUBLIC - Generate temporary merged Brewfile with all dependencies (core + modules + user)
update_merge_into() {

    # Variables
    local output_brewfile="$1"
    local descriptor=""
    local formulae=()
    local casks=()

    # Check arguments
    if [[ -z "${output_brewfile}" ]]; then
        printStyled error "Expected : <output_brewfile> (received : ${1})"
        return 1
    fi

    # Reset merged file
    echo "" > "${output_brewfile}" || {
        printStyled error "Unable to create merged Brewfile: ${output_brewfile}"
        return 1
    }

    # Merge content
    for descriptor in "${FILES_TOOLS[@]}"; do
        [[ ! -f "${descriptor}" ]] && continue
        formulae=("${(@f)$(file_read "${descriptor}" formulae)}")
        casks=("${(@f)$(file_read "${descriptor}" casks)}")

        # Intro
        {
            echo ""
            echo "############################################"
            echo "# Dependencies from ${descriptor}:"
            echo ""
        } >> "${output_brewfile}" || printStyled warning "Unable to write into: ${output_brewfile}"

        # Content
        file_add "${output_brewfile}" formulae "${formulae[@]}"
        file_add "${output_brewfile}" casks "${casks[@]}"

        # Final line
        echo "" >> "${output_brewfile}"
    done
}

# PRIVATE - Execute the update process and save new status in config file
_update_run_from() {
    local brewfile="${1}"
    # Update Homebrew, formulae and casks (Implemented in `gacli/modules/.core/brew.zsh`)
    brew_bundle "${brewfile}" || return 1

    # Update variables
    LAST_UPDATE="${TODAY}"
    if [[ $AUTO_UPDATE = true ]]; then
        if ! NEXT_UPDATE="$(time_add_days "${LAST_UPDATE}" "${FREQ_DAYS}")"; then
            printStyled warning "Failed to compute next update date"
            printStyled warning "Auto-update disabled"
            AUTO_UPDATE=false
            NEXT_UPDATE=""
        fi
    fi

    # Save
    _update_set_config

    # Display result
    printStyled success "Updated 🚀"
    _update_display_next
}

# ────────────────────────────────────────────────────────────────
# CONFIG MANAGEMENT
# ────────────────────────────────────────────────────────────────

# PRIVATE - Load auto-update config from config file or trigger config file initialization
_update_get_config() {

    # Read values from config file
    INITIALIZED="$(file_read "${FILE_CONFIG_UPDATE}" "initialized")" || return 1
    AUTO_UPDATE="$(file_read "${FILE_CONFIG_UPDATE}" "auto_update")" || return 1
    LAST_UPDATE="$(file_read "${FILE_CONFIG_UPDATE}" "last_update")" || return 1
    FREQ_DAYS="$(file_read "${FILE_CONFIG_UPDATE}" "freq_days")" || return 1
    NEXT_UPDATE="$(file_read "${FILE_CONFIG_UPDATE}" "next_update")" || return 1

    # Get current date
    TODAY="$(time_get_current)" || return 1

    # Init config at first launch
    if [[ $INITIALIZED != "true" ]]; then
        update_edit_config || return 1
        return 0
    fi
}

# PUBLIC - Configure auto-update settings based on user input
update_edit_config() {

    # Ask for auto-update frequency
    _update_ask_freq || return 1

    # Setup auto-update
    if [[ $FREQ_DAYS = 0 || -z $FREQ_DAYS ]]; then
        AUTO_UPDATE="false"
        NEXT_UPDATE=""
    else
        if ! NEXT_UPDATE="$(time_add_days "${TODAY}" "${FREQ_DAYS}")"; then
            printStyled warning "Failed to compute next update date"
            printStyled warning "Auto-update disabled"
            AUTO_UPDATE=false
            NEXT_UPDATE=""
        else
            AUTO_UPDATE="true"
        fi
    fi

    # Save
    INITIALIZED="true"
    _update_set_config || return 1
    _update_display_next
    echo ""
}

# PRIVATE - Save current update config values to config file
_update_set_config() {

    file_write "${FILE_CONFIG_UPDATE}" "initialized" "${INITIALIZED}" || return 1
    file_write "${FILE_CONFIG_UPDATE}" "auto_update" "${AUTO_UPDATE}" || return 1
    file_write "${FILE_CONFIG_UPDATE}" "last_update" "${LAST_UPDATE}" || return 1
    file_write "${FILE_CONFIG_UPDATE}" "freq_days" "${FREQ_DAYS}" || return 1
    file_write "${FILE_CONFIG_UPDATE}" "next_update" "${NEXT_UPDATE}" || return 1
}

# ────────────────────────────────────────────────────────────────
# I/O
# ────────────────────────────────────────────────────────────────

# PRIVATE - Ask user for auto-update frequency (type safe)
_update_ask_freq() {

    while true; do
        echo ""
        print -n "👉 ${BOLD}How many days between each auto-update? (OFF = 0) ${NONE}"
        read -r FREQ_DAYS

        # Check format
        if [[ "$FREQ_DAYS" =~ ^[0-9]+$ ]]; then
            break
        else
            printStyled "error" "⛔ Invalid input. Please enter a number\n"
        fi
    done
}

# PRIVATE - Display the next scheduled auto-update date or status
_update_display_next() {
    # Display next update date
    if [[ $AUTO_UPDATE = true ]]; then
        printStyled info "Next update on: $(time_to_human "${NEXT_UPDATE}")"
    else
        printStyled info "Auto updates disabled"
    fi
}

#!/usr/bin/env zsh
###############################
# FICHIER /src/logic/modules.zsh
###############################

# Github repo containing all available modules
MODULES_LIB="https://raw.githubusercontent.com/guillaumeast/gacli-hub/refs/heads/master/modules"

# Modules signature
ENTRY_POINT="main.zsh"
CONFIG_FILE="tools.json"

# Active modules and commands
MODULES_INSTALLED=()
MODULES_ACTIV=()

# ────────────────────────────────────────────────────────────────
# DOWNLOAD FILES
# ────────────────────────────────────────────────────────────────

# PUBLIC - Download and merge all modules
modules_init() {
    local modules_raw=()
    local modules_to_check=()

    # Reset merged file
    file_reset "${FILE_TOOLS_MODULES}" formulae || return 1
    file_reset "${FILE_TOOLS_MODULES}" casks || return 1
    file_reset "${FILE_TOOLS_MODULES}" modules || return 1

    # Get modules list from $DIR_MODS
    setopt local_options nullglob # Avoid errors when DIR_MODS is empty
    local folders=("${DIR_MODS}"/*(/))
    if [[ ${#folders[@]} -gt 0 ]]; then
        local module_path
        for module_path in "${folders[@]}"; do
            modules_to_check+=("${module_path##*/}")
        done
    fi

    # Get modules list from $FILE_TOOLS_USER
    modules_raw+=("${(@f)$(file_read "${FILE_TOOLS_USER}" modules)}") || return 1
    if [[ ${#modules_raw[@]} -gt 0 ]]; then
        for module in "${modules_raw[@]}"; do
            [[ -z "$module" ]] && continue
            modules_to_check+=("${module}")
        done
    fi

    # Modules are optional
    [[ ${#modules_to_check[@]} = 0 ]] && return 0

    # Download modules and merge dependencies (recursively)
    for module in "${modules_to_check[@]}"; do
        _module_download "${module}" || continue
    done
}

# PRIVATE - Download a module and merge dependencies (recursively)
_module_download() {
    local module="${1}"
    local config=""
    local list=()

    # Download module if needed
    if ! _module_is_downloaded "${module}"; then
        local descriptor_url="${MODULES_LIB}/${module}.json"
        local tmp_descriptor="${DIR_TMP}/${module}.json"
        local module_url=""

        # Download descriptor file (abstract curl / get handling into a /.helpers/http.zsh file)
        curl "${descriptor_url}" > "${tmp_descriptor}" || {
            printStyled error "Unable to download descriptor of: ${module}"
            printStyled error "→ url: ${descriptor_url}"
            printStyled error "Check module descriptor at: ${descriptor_url}"
            rm -f "$tmp_descriptor"
            return 1
        }

        # Check descriptor integrity
        [[ -f "${tmp_descriptor}" ]] || {
            printStyled error "Unable to download descriptor of: ${module}"
            printStyled error "→ url: ${descriptor_url}"
            printStyled error "Check module descriptor at: ${descriptor_url}"
            rm -f "$tmp_descriptor"
            return 1
        }

        # Get archive url
        module_url=$(file_read "${tmp_descriptor}" module_url) || {
            printStyled error "Unable to parse descriptor of: ${module}"
            rm -f "${tmp_descriptor}"
            return 1
        }
        rm -f "${tmp_descriptor}"

        # Check url integrity
        [[ -n "${module_url}" ]] || {
            printStyled error "Unable to extract url of: ${module}"
            printStyled error "→ Check module descriptor at: ${descriptor_url}"
            rm -f "$tmp_descriptor"
            return 1
        }

        # Download module archive
        local tmp_archive="$(mktemp)"
        if ! curl -sL "${module_url}" --output "${tmp_archive}"; then
            printStyled error "Unable to download module archive"
            printStyled error "→ url: ${module_url}"
            rm -f "$tmp_archive"
            return 1
        fi

        # Create target directory
        mkdir -p "${DIR_MODS}/${module}" || {
            printStyled error "Failed to create module directory: ${DIR_MODS}/${module}"
            rm -f "$tmp_archive"
            return 1
        }

        # Extract archive to module directory
        if ! tar --strip-components=1 -xzf "$tmp_archive" -C "${DIR_MODS}/${module}"; then
            printStyled error "Failed to extract archive: ${tmp_archive}"
            rm -f "$tmp_archive"
            return 1
        fi

        # Cleanup
        rm -f "$tmp_archive"

        # Check integrity
        _module_is_downloaded "${module}" || {
            printStyled error "Unable to recognize module: ${module}"
            return 1
        }
    fi

    # Download nested modules (recursive)
    config="${DIR_MODS}/${module}/${CONFIG_FILE}"
    list=("${(@f)$(file_read "${config}" modules)}")
    for nested_module in "${list[@]}"; do
        [[ -z "${nested_module}" ]] && continue
        if ! _module_is_downloaded "${nested_module}"; then
            _module_download "${nested_module}" || {
                printStyled error "Unable to download nested module: ${nested_module}"
                return 1
            }
        fi
    done

    # Add to installed modules variable
    MODULES_INSTALLED+=("${module}")

    # Merge dependencies
    list=("${(@f)$(file_read "${DIR_MODS}/${module}/${CONFIG_FILE}" formulae)}")
    file_add "${FILE_TOOLS_MODULES}" formulae "${list[@]}" || {
        printStyled error "Unable to merge modules dependencies"
        return 1
    }
    list=("${(@f)$(file_read "${DIR_MODS}/${module}/${CONFIG_FILE}" casks)}")
    file_add "${FILE_TOOLS_MODULES}" casks "${list[@]}"|| {
        printStyled error "Unable to merge modules dependencies"
        return 1
    }
    list=("${(@f)$(file_read "${DIR_MODS}/${module}/${CONFIG_FILE}" modules)}")
    file_add "${FILE_TOOLS_MODULES}" modules "${list[@]}"|| {
        printStyled error "Unable to merge modules dependencies"
        return 1
    }
}

# PRIVATE - Check if a module is correctly installed
_module_is_downloaded() {

    # Resolve paths
    local module="${1}"
    local module_path="${DIR_MODS}/${module}"
    local entry_point="${module_path}/${ENTRY_POINT}"
    local config_file="${module_path}/${CONFIG_FILE}"

    # Check signatures
    [[ -d "${module_path}" ]] || return 1
    [[ -f "${entry_point}" ]] || return 1
    [[ -f "${config_file}" ]] || return 1
}

# ────────────────────────────────────────────────────────────────
# SOURCE CODE
# ────────────────────────────────────────────────────────────────

# PUBLIC - Source installed modules and activate their commands
modules_load() {
    
    local module=""
    local entry_point=""
    for module in "${MODULES_INSTALLED[@]}"; do
        entry_point="${DIR_MODS}/${module}/${ENTRY_POINT}"
        [[ ! -f "${entry_point}" ]] && continue
        source "${entry_point}" || {
            printStyled warning "Unable to load module: ${module}"
            continue
        }
        _module_get_commands "${entry_point}" || {
            printStyled warning "Unable to fetch module commands: ${module}"
            continue
        }
        MODULES_ACTIV+=("${module}")
    done
}

# PRIVATE - Extract dynamic commands list from a module via get_commands
_module_get_commands() {
    local file="$1"
    local commands=()

    # Argument check
    if [[ ! -f "$file" ]]; then
        printStyled error "Incorrect file : ${1}"
        return 1
    fi

    # Clear hash table (before)
    if typeset -f get_commands >/dev/null; then
        unfunction get_commands
    fi

    # Source module file (TODO: do it in a subshell to avoid double sourcing issues ?)
    source "${file}"
    if (( $? != 0 )); then
        printStyled error "Failed to load file : ${1}"
        return 1
    fi

    # Check if get_commands is implemented
    if ! typeset -f get_commands >/dev/null; then
        return 1
    fi

    # Capture and validate output
    commands=("${(@f)$(get_commands)}")
    if (( $? != 0 )); then
        unfunction get_commands
        return 1
    else
        unfunction get_commands
    fi

    # Return commands
    local cmd=""
    for cmd in "${commands[@]}"; do
        [[ -n "$cmd" && $cmd == *=* ]] || continue
        COMMANDS_MODS+=("${cmd}")
    done
}

#!/usr/bin/env zsh
###############################
# FICHIER /src/main.zsh
###############################

# Easter egg display
if [[ $1 == "" ]]; then
    print "\033[90m✧ Don't panic... 🐥\033[0m"
fi

# Env
setopt extended_glob
IS_MACOS=false
IS_LINUX=false

# Check $HOME is set
if [ -z "${HOME}" ] || [ ! -d "${HOME}" ]; then
    echo " ---> [GACLI] E1: fatal error, exiting GACLI <---" >&2
    exit "1"
fi

# Directories
DIR_ROOT="${HOME}/.gacli"
DIR_DATA="${DIR_ROOT}/data"
DIR_CONFIG="${DIR_DATA}/config"
DIR_TOOLS="${DIR_DATA}/tools"
DIR_HELPERS="${DIR_ROOT}/helpers"
DIR_LOGIC="${DIR_ROOT}/logic"
DIR_MODS="${DIR_ROOT}/modules"
DIR_TMP="${DIR_ROOT}/.tmp"
DIRS=("${DIR_ROOT}" "${DIR_DATA}" "${DIR_CONFIG}" "${DIR_TOOLS}" "${DIR_HELPERS}" "${DIR_LOGIC}" "${DIR_MODS}" "${DIR_TMP}")

# Config files
FILE_CONFIG_UPDATE="${DIR_CONFIG}/update.config.json"
FILES_CONFIG=("${FILE_CONFIG_UPDATE}")

# Tools files
FILE_TOOLS_CORE="${DIR_TOOLS}/core.tools.json"
FILE_TOOLS_MODULES="${DIR_TOOLS}/modules.tools.json"
FILE_TOOLS_USER="${DIR_TOOLS}/user.tools.json"
FILES_TOOLS=("${FILE_TOOLS_CORE}" "${FILE_TOOLS_MODULES}" "${FILE_TOOLS_USER}")

# Scripts files
SCRIPTS=( \
    "${DIR_ROOT}/helpers/time.zsh" \
    "${DIR_ROOT}/helpers/parser.zsh" \
    "${DIR_ROOT}/helpers/brew.zsh" \
    "${DIR_ROOT}/logic/update.zsh" \
    "${DIR_ROOT}/logic/modules.zsh" \
    "${DIR_ROOT}/logic/uninstall.zsh" \
)

# Available commands
COMMANDS_CORE=("help=help" "config=update_edit_config" "update=update_manual" "uninstall=gacli_uninstall")
COMMANDS_MODS=()

# Formatting
BOLD="\033[1m"
UNDERLINE="\033[4m"
BLACK='\033[30m'
RED='\033[31m'
GREEN='\033[32m'
YELLOW='\033[33m'
BLUE='\033[34m'
PURPLE='\033[35m'
CYAN='\033[36m'
ORANGE='\033[38;5;208m'
GREY='\033[90m'
NONE='\033[0m'
COLOR_FORMULAE="${BLUE}"
COLOR_CASKS="${CYAN}"
COLOR_MODS="${PURPLE}"
COLOR_COMMANDS="${ORANGE}"

# Emojis
EMOJI_SUCCESS="✓"
EMOJI_WARN="⚠️"
EMOJI_ERR="🛑"
EMOJI_INFO="✧"
EMOJI_HIGHLIGHT="👉"
EMOJI_DEBUG="🔎"
EMOJI_WAIT="⏳"
ICON_ON="⊙"
ICON_OFF="○"

# ────────────────────────────────────────────────────────────────
# MAIN
# ────────────────────────────────────────────────────────────────

# Main function
main() {

    # Check gacli install
    if ! command -v gacli > /dev/null 2>&1; then
        printStyled error "gacli command not found"
        printStyled highlight "Try to restart your terminal or run: exec zsh"
        return 1
    fi

    # Check env compatibility and files integrity
    _gacli_check_system || abort "1" || return 1
    _gacli_check_files || abort "2" || return 1

    # Load core scripts
    local script
    for script in "${SCRIPTS[@]}"; do
        if ! source "${script}"; then
            printStyled error "Unable to load required script: ${script}"
            abort "3" || return 1
        fi
    done

    # Load modules and check if update is due (date or new dependencies)
    modules_init || abort "4" || return 1           # Implemented in modules.zsh
    update_init  || abort "5" || return 1           # Implemented in update.zsh
    modules_load || abort "6" || return 1           # Implemented in modules.zsh

    # Dispatch commands
    _gacli_dispatch "$@" || abort "7" || return 1
}

# ────────────────────────────────────────────────────────────────
# CORE LOGIC
# ────────────────────────────────────────────────────────────────

# PRIVATE - Detect the operating system and set the corresponding flags
_gacli_check_system() {
    if [[ -z "$OSTYPE" ]]; then
        printStyled error "\$OSTYPE is not set" >&2
        return 1
    fi

    case "$OSTYPE" in
        darwin*) IS_MACOS=true ;;
        linux*)  IS_LINUX=true ;;
        *)
            printStyled error "Unknown OS type: $OSTYPE" >&2
            return 1
            ;;
    esac
}

# PRIVATE - Check files integrity
_gacli_check_files() {
    local dir file
    local files=("${FILES_CONFIG[@]}" "${FILES_TOOLS[@]}")

    # Check directories integrity
    for dir in "${DIRS[@]}"; do
        mkdir -p "${dir}" || {
            printStyled error "Unable to resolve dir: ${dir}"
            return 1
        }
    done

    # Check files integrity
    for file in "${files[@]}"; do
        touch "${file}" || {
            printStyled error "Unable to resolve file: ${file}"
            return 1
        }
    done
}

# PRIVATE - Dispatch commands
_gacli_dispatch() {
    case "$1" in
        "")
            style_ascii_logo
            print_formulae
            print_casks
            print_modules
            print_core_commands
            print_mods_commands
            echo ""
            ;;
        *)
            # Dynamic commands (declared via get_commands in modules)
            local commands=("${COMMANDS_CORE[@]}" "${COMMANDS_MODS[@]}")
            for cmd in "${commands[@]}"; do
                local command_name="${cmd%%=*}"
                local function_name="${cmd#*=}"

                if [[ "$1" == "$command_name" ]]; then
                    # Call matched function with remaining args
                    "${function_name}" "${@:2}"
                    return "$?"
                fi
            done

            # No command matched
            printStyled error "Unknown command '$1'" >&2
            modules_print_commands
            return 1
            ;;
    esac
}

# PUBLIC - Display a fatal error message and exit the script
abort() {
    echo ""
    echo "-------------------------------------------------------"
    echo " ---> [GACLI] E${1}: fatal error, exiting GACLI <---" >&2
    echo "-------------------------------------------------------"
    echo ""
    return 1
}

# ────────────────────────────────────────────────────────────────
# OUTPUTS
# ────────────────────────────────────────────────────────────────

# PUBLIC - ASCII art logo
style_ascii_logo() {
    print "${ORANGE}  _____          _____ _      _____ ${NONE}"
    print "${ORANGE} / ____|   /\\\\   / ____| |    |_   _|${NONE}"
    print "${ORANGE}| |  __   /  \\\\ | |    | |      | |  ${NONE}"
    print "${ORANGE}| | |_ | / /\\\\ \\\\| |    | |      | |  ${NONE}"
    print "${ORANGE}| |__| |/ ____ \\\\ |____| |____ _| |_ ${NONE}"
    print "${ORANGE} \\\\_____/_/    \\\\_\\\\_____|______|_____|${NONE}"
    print ""
}

# PUBLIC - Display formatted message
printStyled() {
    # Variables
    local style=$1
    local raw_message=$2
    local final_message=""
    local color=$NONE

    # Argument check
    if [[ -z "$style" || -z "$raw_message" ]]; then
        echo "❌ [printStyled] Expected: <style> <message>"
        return 1
    fi

    # Formatting
    case "$style" in
        error)
            echo "${RED}${BOLD}${EMOJI_ERR} [${RED}${funcstack[2]}${GREY}] → ${RED}${raw_message}${NONE}" >&2
            return
            ;;
        warning)
            print "${YELLOW}${BOLD}${EMOJI_WARN} [${ORANGE}${funcstack[2]}${GREY}] → ${ORANGE}${raw_message}${NONE}" >&2
            return
            ;;
        success)
            color=$GREEN
            final_message="${EMOJI_SUCCESS} ${raw_message}"
            ;;
        info)
            color=$GREY
            final_message="${EMOJI_INFO} ${raw_message}"
            ;;
        highlight)
            color=$NONE
            final_message="${EMOJI_HIGHLIGHT} ${raw_message}"
            ;;
        debug)
            color=$YELLOW
            final_message="${EMOJI_DEBUG} ${GREY}${funcstack[4]}${GREY} → ${GREY}${funcstack[3]}${GREY} → ${YELLOW}${funcstack[2]}${GREY}\n    ${YELLOW}└→ ${BOLD}${raw_message}${NONE}"
            ;;
        *)
            color=$NONE
            final_message="${raw_message}"
            ;;
    esac

    # Display
    print "${color}$final_message${NONE}"
}

# PUBLIC - Diplay tips
help() {
    print ""
    print "${GREY}→ Formulaes → https://formulae.brew.sh/formula ${NONE}"
    print_formulae

    print ""
    print "${GREY}→ Casks → https://formulae.brew.sh/cask/ ${NONE}"
    print_casks

    print ""
    print "${GREY}→ Modules → https://github.com/guillaumeast/gacli ${NONE}"
    print_modules

    print ""
    print "${GREY}→ Core commands${NONE}"
    print_core_commands

    print ""
    print "${GREY}→ Modules commands${NONE}"
    print_mods_commands
    print ""
}

# PUBLIC - Print installed status for all formulae defined in tools descriptors
print_formulae() {
    local tmp_brewfile="${DIR_TMP}/Brewfile"
    local formula
    local output

    # Get merged casks
    update_merge_into "${tmp_brewfile}" || {
        rm -f "${tmp_brewfile}"
        return 1
    }
    
    formulae+=("${(@f)$(file_read "${tmp_brewfile}" formulae)}") || {
        rm -f "${tmp_brewfile}"
        return 1
    }

    # Compute
    for formula in "${formulae[@]}"; do
        formula="${formula#"${formula%%[![:space:]]*}"}"  # Trim leading spaces
        formula="${formula%"${formula##*[![:space:]]}"}"  # Trim trailing spaces
        [[ -z $formula || "$formula" == "" ]] && continue
        local icon="${RED}${ICON_OFF}${NONE}"
        local color=$RED
        brew_is_f_active "${formula}" && {
            icon="${GREEN}${ICON_ON}${NONE}"
            color=$COLOR_FORMULAE
        }
        output+="${icon} ${color}$formula ${GREY}|${NONE} "
    done

    # Display (removing trailing " | ")
    [[ -n "${output}" ]] && print "${output% ${GREY}|${NONE} }"

    # Delete temporary Brewfile
    rm -f "${tmp_brewfile}"
}

# PUBLIC - Print installed status for all casks defined in tools descriptors
print_casks() {
    local tmp_brewfile="${DIR_TMP}/Brewfile"
    local casks=()
    local cask=""
    local output=""

    # Get merged casks
    update_merge_into "${tmp_brewfile}" || {
        rm -f "${tmp_brewfile}"
        return 1
    }
    casks=("${(@f)$(file_read "${tmp_brewfile}" casks)}") || {
        rm -f "${tmp_brewfile}"
        return 1
    }

    # Compute
    for cask in "${casks[@]}"; do
        cask="${cask#"${cask%%[![:space:]]*}"}"  # Trim leading spaces
        cask="${cask%"${cask##*[![:space:]]}"}"  # Trim trailing spaces
        [[ -z $cask || "$cask" == "" ]] && continue
        local icon="${RED}${ICON_OFF}${NONE}"
        local color=$RED
        brew_is_c_active "${cask}" && {
            icon="${GREEN}${ICON_ON}${NONE}"
            color=$COLOR_CASKS
        }
        output+="${icon} ${color}$cask ${GREY}|${NONE} "
    done

    # Display (removing trailing " | ")
    [[ -n "${output}" ]] && print "${output% ${GREY}|${NONE} }"

    # Delete temporary Brewfile
    rm -f "${tmp_brewfile}"
}

# PUBLIC - Print installed status for all installed modules
print_modules() {
    local output=""
    local icon

    for module in "${MODULES_INSTALLED[@]}"; do
        module="${module#"${module%%[![:space:]]*}"}"  # Trim leading spaces
        module="${module%"${module##*[![:space:]]}"}"  # Trim trailing spaces
        [[ -z $module || "$module" == "" ]] && continue
        local icon="${RED}${ICON_OFF}${NONE}"
        local color=$RED
        [[ " $MODULES_ACTIV " == *" $module "* ]] && {
            icon="${GREEN}${ICON_ON}${NONE}"
            color=$COLOR_MODS
        }
        output+="${icon} ${color}$module ${GREY}|${NONE} "
    done
    
    # Display (removing trailing " | ")
    [[ -n "${output}" ]] && print "${output% ${GREY}|${NONE} }"
}

# PUBLIC - Print available built-in GACLI core commands
print_core_commands() {
    local output

    for cmd in "${COMMANDS_CORE[@]}"; do
        local command_name="${cmd%%=*}"
        output+="${GREEN}${ICON_ON} ${COLOR_COMMANDS}${command_name} ${GREY}|${NONE} "
    done
    print "${output% ${GREY}|${NONE} }"
}

# PUBLIC - Print available commands provided by loaded modules
print_mods_commands() {
    local output

    for cmd in "${COMMANDS_MODS[@]}"; do
        local command_name="${cmd%%=*}"
        output+="${GREEN}${ICON_ON} ${COLOR_COMMANDS}${command_name} ${GREY}|${NONE} "
    done
    [[ -n "${output}" ]] && print "${output% ${GREY}|${NONE} }"
}

# ────────────────────────────────────────────────────────────────
# RUN
# ────────────────────────────────────────────────────────────────

# Call main with all command args
main "$@"

#!/usr/bin/env zsh
###############################
# FICHIER /src/logic/uninstall.zsh
###############################

# Uninstall GACLI: remove all file and cleanup .zshrc
gacli_uninstall() {
    printStyled info "Uninstalling... ⏳"

    # Variables
    local zshrc_file="$HOME/.zshrc"

    # Remove GACLI lines from .zshrc
    print ""
    printStyled info "Updating .zshrc file... ⏳"
    if [[ -f "${zshrc_file}" ]]; then
        cp "${zshrc_file}" "${zshrc_file}.bak" || {
            printStyled error "Failed to backup zshrc file"
            return 1
        }

        # Remove all GACLI lines (header + source + alias)
        grep -vE '^# GACLI$|^export PATH="\$HOME/.local/bin:\$PATH"$|^source "\$HOME/.gacli/gacli.zsh"$' "${zshrc_file}" > "${zshrc_file}.tmp" || {
            printStyled error "Failed to parse zshrc file"
            return 1
        }


        mv "${zshrc_file}.tmp" "$zshrc_file" || {
            printStyled error "Failed to update zshrc file"
            return 1
        }

    else
        printStyled warning ".zshrc file not found ($zshrc_file)"
    fi
    printStyled success "Updated"

    # Remove GACLI wrapper
    print ""
    printStyled info "Removing wrapper... ⏳"
    local wrapper_path="${HOME}/.local/bin/gacli"
    if [[ -f "${wrapper_path}" ]]; then
        rm -f "${wrapper_path}" || {
            printStyled warning "Failed to delete wrapper ${wrapper_path}"
        }
    fi
    printStyled success "Removed"

    # Delete GACLI directory
    print ""
    printStyled info "Deleting GACLI files... ⏳"
    if [[ -d "${GACLI_DIR}" ]]; then
        rm -rf "${GACLI_DIR}" || {
            printStyled error "Failed to delete directory ${GACLI_DIR}"
            return 1
        }
    else
        printStyled error "Unable to find GACLI directory: ${GACLI_DIR}"
        return 1
    fi
    printStyled success "Deleted"

    print ""
    printStyled success "Uninstall complete ✅"
    print ""
    printStyled highlight "Restart your terminal"
    print ""
}

