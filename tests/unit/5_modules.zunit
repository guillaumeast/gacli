#!/usr/bin/env zunit
###############################
# FICHIER /tests/unit/modules.zunit
###############################

@setup {

    # Setup env
    load "${DIR_SRC}/helpers/time.zsh"
    load "${DIR_SRC}/helpers/parser.zsh"
    load "${DIR_SRC}/helpers/brew.zsh"
    load "${DIR_SRC}/logic/update.zsh"

    # Fixtures
    DIR_MODS_SAMPLES="${DIR_TESTS}/fixture/modules/"
    MODULE_CORRUPTED_ENTRY_POINT="corrupted_entry_point"
    MODULE_CORRUPTED_TOOLS="corrupted_tools"
    MODULE_UNINSTALLED="wrong_name"
    MODULE_VALID="sample_module"
    MODULE_NESTED="sample_nested_module"

    # Load script to test
    load "${DIR_SRC}/logic/modules.zsh"

    # Shadowing variables
    DIR_TEST_TMP="${DIR_TESTS}/fixture/modules/.tmp"
    DIR_MODS="${DIR_TEST_TMP}/modules"
    DIR_TMP="${DIR_TEST_TMP}/tools"
    FILE_TOOLS_MODULES="${DIR_TMP}/modules.tools.json"
    FILE_TOOLS_USER="${DIR_TMP}/user.tools.json"
    MODULES_INSTALLED=()
    MODULES_ACTIV=()
    COMMANDS_MODS=()

    # Reset temporary files
    [[ -d "${DIR_TEST_TMP}" ]] && rm -r "${DIR_TEST_TMP}"
    mkdir -p "${DIR_MODS}"
    mkdir -p "${DIR_TMP}"
    cp "${DIR_SRC}/data/tools/modules.tools.json" "${FILE_TOOLS_MODULES}"
    cp "${DIR_SRC}/data/tools/user.tools.json" "${FILE_TOOLS_USER}"
}

# ────────────────────────────────────────────────────────────────
# TESTS
# ────────────────────────────────────────────────────────────────

@test 'MODULES      → Detect if module is already downloaded        → false (uninstalled)' {

    # Set fake path
    DIR_MODS="${DIR_MODS_SAMPLES}"

    # Check
    run _module_is_downloaded "${MODULE_UNINSTALLED}"
    assert $state equals 1
}

@test 'MODULES      → Detect if module is already downloaded        → false (corrupted entry point)' {

    # Set fake path
    DIR_MODS="${DIR_MODS_SAMPLES}"

    # Check
    run _module_is_downloaded "${MODULE_CORRUPTED_ENTRY_POINT}"
    assert $state equals 1
}

@test 'MODULES      → Detect if module is already downloaded        → false (corrupted tools)' {

    # Set fake path
    DIR_MODS="${DIR_MODS_SAMPLES}"

    # Check
    run _module_is_downloaded "${MODULE_CORRUPTED_TOOLS}"
    assert $state equals 1
}

@test 'MODULES      → Detect if module is already downloaded        → true' {

    # Set fake path
    DIR_MODS="${DIR_MODS_SAMPLES}"

    # Check
    run _module_is_downloaded "${MODULE_VALID}"
    assert $state equals 0
}

@test 'MODULES      → Download module files' {

    # Download module
    _module_download "${MODULE_VALID}"
    assert $? equals 0
    assert "${MODULE_VALID}" in $MODULES_INSTALLED
    assert "${MODULE_NESTED}" in $MODULES_INSTALLED
}
    
@test 'MODULES      → Init modules                                  → (via modules/)' {

    # Pre-install (download) module
    _module_download "${MODULE_VALID}"

    # Init modules
    modules_init
    assert $? equals 0
    assert "${MODULE_VALID}" in $MODULES_INSTALLED
    assert "${MODULE_NESTED}" in $MODULES_INSTALLED

    # Check merged dependencies
    local merged_modules=("${(@f)$(file_read "${FILE_TOOLS_MODULES}" modules)}")
    local merged_formulae=("${(@f)$(file_read "${FILE_TOOLS_MODULES}" formulae)}")
    local merged_casks=("${(@f)$(file_read "${FILE_TOOLS_MODULES}" casks)}")
    local module=""
    local tools=""
    local item=""
    local list=()
    for module in $MODULES_INSTALLED; do

        tools="${DIR_MODS}/${module}/${CONFIG_FILE}"

        # Check nested modules
        list=("${(@f)$(file_read "${tools}" modules)}")
        for item in $list; do
            assert "${item}" in $merged_modules
        done

        # Check formulae
        list=("${(@f)$(file_read "${tools}" formulae)}")
        for item in $list; do
            assert "${item}" in $merged_formulae
        done

        # Check casks
        list=("${(@f)$(file_read "${tools}" casks)}")
        for item in $list; do
            assert "${item}" in $merged_casks
        done
    done
}

@test 'MODULES      → Init modules                                  → (via user.tools.json)' {

    # Declare module
    file_add "${FILE_TOOLS_USER}" modules "${MODULE_VALID}"

    # Init modules
    modules_init
    assert $? equals 0
    assert "${MODULE_VALID}" in $MODULES_INSTALLED
    assert "${MODULE_NESTED}" in $MODULES_INSTALLED

    # Check merged dependencies
    local merged_modules=("${(@f)$(file_read "${FILE_TOOLS_MODULES}" modules)}")
    local merged_formulae=("${(@f)$(file_read "${FILE_TOOLS_MODULES}" formulae)}")
    local merged_casks=("${(@f)$(file_read "${FILE_TOOLS_MODULES}" casks)}")
    local module=""
    local tools=""
    local item=""
    local list=()
    for module in $MODULES_INSTALLED; do

        tools="${DIR_MODS}/${module}/${CONFIG_FILE}"

        # Check nested modules
        list=("${(@f)$(file_read "${tools}" modules)}")
        for item in $list; do
            assert "${item}" in $merged_modules
        done

        # Check formulae
        list=("${(@f)$(file_read "${tools}" formulae)}")
        for item in $list; do
            assert "${item}" in $merged_formulae
        done

        # Check casks
        list=("${(@f)$(file_read "${tools}" casks)}")
        for item in $list; do
            assert "${item}" in $merged_casks
        done
    done
}

@test 'MODULES      → Fetch module commands' {

    local entry_point="${DIR_MODS_SAMPLES}/${MODULE_VALID}/${ENTRY_POINT}"
    local COMMANDS_MODS=()

    _module_get_commands "${entry_point}"
    assert $? equals 0

    assert "${#COMMANDS_MODS[@]}" equals 2
    assert 'being_curious=asking_questions' in $COMMANDS_MODS
    assert 'ultimate_question=ultimate_answer' in $COMMANDS_MODS
}

@test 'MODULES      → Resolve the ultimate query                    → (via user.tools.json)' {

    # Declare module
    file_add "${FILE_TOOLS_USER}" modules "${MODULE_VALID}"

    # Init modules
    modules_init

    # Load modules
    modules_load
    assert $? equals 0
    assert "${MODULE_VALID}" in $MODULES_ACTIV
    assert "${MODULE_NESTED}" in $MODULES_ACTIV
    assert 'being_curious=asking_questions' in $COMMANDS_MODS
    assert 'ultimate_question=ultimate_answer' in $COMMANDS_MODS
    assert 'nested_command=nested_function' in $COMMANDS_MODS

    # Test sample_module
    run asking_questions
    assert $state equals 0
    assert $output same_as '...'

    run ultimate_answer
    assert $state equals 0
    assert $output same_as "${ULTIMATE_ANSWER}"

    # Test nested module
    run nested_function
    assert $state equals 0
    assert $output same_as 'nested answer'
}

@teardown {

    # Delete temporary files
    [[ -d "${DIR_TEST_TMP}" ]] && rm -r "${DIR_TEST_TMP}"
}

